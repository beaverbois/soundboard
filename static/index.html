<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soundboard</title>
    <script src="/static/htmx.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              "dark-bg": "#222",
              "dark-text": "#eee",
              "dark-muted": "#888",
            },
          },
        },
      };
    </script>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body class="min-h-screen bg-dark-bg text-dark-text font-sans">
    <div
      class="min-h-screen flex flex-col items-center justify-center p-5 relative"
    >
      <!-- Stop button (top right) -->
      <button
        id="stop-btn"
        class="fixed w-12 h-12 rounded-full border-2 border-gray-600 text-gray-400 hover:border-gray-500 hover:text-gray-300 bg-gray-800 hover:bg-gray-700 transition-all duration-200 flex items-center justify-center active:scale-95 top-4 right-36 z-10"
        onclick="stopAllSounds()"
        aria-label="Stop all sounds"
      >
        <img
          src="/static/icons/cancel.svg"
          width="20"
          height="20"
          alt="Stop"
          class="filter brightness-0 invert"
        />
      </button>

      <!-- Edit button (top right) -->
      <button
        id="edit-btn"
        class="fixed w-12 h-12 rounded-full border-2 border-gray-600 text-gray-400 hover:border-gray-500 hover:text-gray-300 bg-gray-800 hover:bg-gray-700 transition-all duration-200 flex items-center justify-center active:scale-95 top-4 right-20 z-10"
        onclick="toggleEditMode()"
        aria-label="Edit sounds"
        style="display: none"
      >
        <img
          src="/static/icons/pencil.svg"
          width="20"
          height="20"
          alt="Edit"
          class="filter brightness-0 invert"
        />
      </button>

      <!-- Settings button (top right, to the right of edit button) -->
      <button
        id="settings-btn"
        class="fixed w-12 h-12 rounded-full border-2 border-gray-600 text-gray-400 hover:border-gray-500 hover:text-gray-300 bg-gray-800 hover:bg-gray-700 transition-all duration-200 flex items-center justify-center active:scale-95 top-4 right-4 z-10"
        onclick="toggleSettingsPanel()"
        aria-label="Settings"
      >
        <img
          src="/static/icons/gear.svg"
          width="20"
          height="20"
          alt="Settings"
          class="filter brightness-0 invert"
        />
      </button>

      <!-- Audio Settings Modal (included from template) -->
      <div
        hx-get="/templates/audio_settings_modal"
        hx-trigger="load"
        hx-swap="outerHTML"
      ></div>

      <!-- Sound Edit Modal (included from template) -->
      <div
        hx-get="/templates/sound_edit_modal"
        hx-trigger="load"
        hx-swap="outerHTML"
      ></div>

      <main class="pt-16 flex flex-col items-center gap-3 w-full max-w-4xl">
        <!-- Sound buttons will be loaded here -->
        <div
          class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-8 w-full mx-auto px-5 justify-items-center"
          id="board"
          role="group"
          aria-label="Sound buttons"
          hx-get="/api/sounds"
          hx-trigger="load"
          hx-swap="innerHTML"
        ></div>

        <!-- Status area for HTMX responses -->
        <div
          id="status"
          class="w-full text-center min-h-[1.2em] text-dark-muted text-sm"
        ></div>
      </main>
    </div>

    <script>
      let editMode = false;
      let sortableInstance = null;

      // Show/hide edit button based on sounds
      function updateEditButtonVisibility() {
        const editBtn = document.getElementById("edit-btn");
        const soundItems = document.querySelectorAll(".sound-item");
        console.log("Edit button visibility check:", {
          editBtn,
          soundItemsCount: soundItems.length,
        });
        if (soundItems.length > 0) {
          editBtn.style.display = "flex";
        } else {
          editBtn.style.display = "none";
        }
      }

      // Edit mode functions
      function toggleEditMode() {
        editMode = !editMode;
        const editBtn = document.getElementById("edit-btn");
        const soundItems = document.querySelectorAll(".sound-item");

        if (editMode) {
          editBtn.innerHTML =
            '<img src="/static/icons/check.svg" width="20" height="20" alt="Done" class="filter brightness-0 invert">';
          editBtn.classList.remove(
            "border-gray-600",
            "text-gray-400",
            "hover:border-gray-500",
            "hover:text-gray-300",
            "bg-gray-800",
            "hover:bg-gray-700"
          );
          editBtn.classList.add(
            "border-green-600",
            "text-green-400",
            "hover:border-green-500",
            "hover:text-green-300",
            "bg-green-800",
            "hover:bg-green-700"
          );

          const editSoundButtons = document.querySelectorAll(".edit-sound-btn");
          const moveOverlays = document.querySelectorAll(".move-overlay");
          const soundButtons = document.querySelectorAll(".btn");

          editSoundButtons.forEach((btn) => btn.classList.remove("hidden"));
          moveOverlays.forEach((overlay) => overlay.classList.remove("hidden"));
          soundItems.forEach((item) => {
            item.classList.add("cursor-move");
          });

          // Disable sound button clicks in edit mode
          soundButtons.forEach((btn) => {
            btn.style.pointerEvents = "none";
          });

          // Enable sortable
          setupSortable();
        } else {
          editBtn.innerHTML =
            '<img src="/static/icons/pencil.svg" width="20" height="20" alt="Edit" class="filter brightness-0 invert">';
          editBtn.classList.remove(
            "border-green-600",
            "text-green-400",
            "hover:border-green-500",
            "hover:text-green-300",
            "bg-green-800",
            "hover:bg-green-700"
          );
          editBtn.classList.add(
            "border-gray-600",
            "text-gray-400",
            "hover:border-gray-500",
            "hover:text-gray-300",
            "bg-gray-800",
            "hover:bg-gray-700"
          );

          const editSoundButtons = document.querySelectorAll(".edit-sound-btn");
          const moveOverlays = document.querySelectorAll(".move-overlay");
          const soundButtons = document.querySelectorAll(".btn");

          editSoundButtons.forEach((btn) => btn.classList.add("hidden"));
          moveOverlays.forEach((overlay) => overlay.classList.add("hidden"));
          soundItems.forEach((item) => {
            item.classList.remove("cursor-move");
          });

          // Re-enable sound button clicks
          soundButtons.forEach((btn) => {
            btn.style.pointerEvents = "";
          });

          // Disable sortable
          if (sortableInstance) {
            sortableInstance.destroy();
            sortableInstance = null;
          }
        }
      }

      function deleteSound(filename) {
        fetch("/api/delete", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: `filename=${encodeURIComponent(filename)}`,
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              htmx
                .ajax("GET", "/api/sounds", {
                  target: "#board",
                  swap: "innerHTML",
                })
                .then(() => {
                  // Re-setup drag and drop and show edit buttons if still in edit mode
                  setupDragAndDrop();
                  updateEditButtonVisibility();
                  if (editMode) {
                    const editSoundButtons =
                      document.querySelectorAll(".edit-sound-btn");
                    const moveOverlays =
                      document.querySelectorAll(".move-overlay");
                    const soundButtons = document.querySelectorAll(".btn");

                    editSoundButtons.forEach((btn) =>
                      btn.classList.remove("hidden")
                    );
                    moveOverlays.forEach((overlay) =>
                      overlay.classList.remove("hidden")
                    );
                    soundButtons.forEach((btn) => {
                      btn.style.pointerEvents = "none";
                    });
                  }
                });
            } else {
              alert("Error deleting sound: " + data.error);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
            alert("Error deleting sound");
          });
      }

      function editSound(filename, currentName, currentColor) {
        const newName = prompt("Enter new name:", currentName);
        if (newName && newName !== currentName) {
          const newColor = prompt("Enter new color (hex):", currentColor);
          if (newColor) {
            fetch("/api/edit", {
              method: "POST",
              headers: { "Content-Type": "application/x-www-form-urlencoded" },
              body: `filename=${encodeURIComponent(
                filename
              )}&name=${encodeURIComponent(newName)}&color=${encodeURIComponent(
                newColor
              )}`,
            }).then(() => {
              htmx.trigger("#board", "load");
            });
          }
        }
      }

      // SortableJS implementation
      function setupSortable() {
        const board = document.getElementById("board");
        if (!board || sortableInstance) return;

        sortableInstance = Sortable.create(board, {
          animation: 150,
          ghostClass: "sortable-ghost",
          chosenClass: "sortable-chosen",
          dragClass: "sortable-drag",
          filter: ".flex.flex-col.items-center.flex-none:not(.sound-item)", // Exclude upload button
          preventOnFilter: false,
          onStart: function (evt) {
            // Darken the original element when drag starts
            evt.item.style.opacity = "0.5";
            evt.item.style.filter = "brightness(0.6)";
          },
          onMove: function (evt) {
            // Prevent moving after upload button
            const uploadButton = board.querySelector(
              ".flex.flex-col.items-center.flex-none:not(.sound-item)"
            );
            return evt.related !== uploadButton;
          },
          onEnd: function (evt) {
            // Restore original element appearance
            evt.item.style.opacity = "";
            evt.item.style.filter = "";
            // Save new order
            saveOrder();
          },
        });
      }

      function saveOrder() {
        const soundItems = document.querySelectorAll(".sound-item");
        const order = Array.from(soundItems).map(
          (item) => item.dataset.filename
        );

        if (order.length > 0) {
          fetch("/api/reorder", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ order: order }),
          }).catch((error) => {
            console.error("Error saving order:", error);
          });
        }
      }

      // Modal functions
      let currentEditingSound = null;

      function openSoundEditModal(filename, name, color) {
        currentEditingSound = filename;
        document.getElementById("edit-sound-name").value = name;
        document.getElementById("edit-button-color").value = color;
        updateEditColorPreview(color);
        document.getElementById("sound-edit-modal").classList.remove("hidden");
      }

      function closeSoundEditModal() {
        currentEditingSound = null;
        document.getElementById("sound-edit-modal").classList.add("hidden");
      }

      function updateEditColorPreview(color) {
        document.getElementById("edit-color-preview").style.background = color;
      }

      function deleteSoundFromModal() {
        if (currentEditingSound) {
          fetch("/api/delete", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: `filename=${encodeURIComponent(currentEditingSound)}`,
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                htmx
                  .ajax("GET", "/api/sounds", {
                    target: "#board",
                    swap: "innerHTML",
                  })
                  .then(() => {
                    updateEditButtonVisibility();
                    if (editMode) {
                      const editSoundButtons =
                        document.querySelectorAll(".edit-sound-btn");
                      const moveOverlays =
                        document.querySelectorAll(".move-overlay");
                      const soundButtons = document.querySelectorAll(".btn");

                      editSoundButtons.forEach((btn) =>
                        btn.classList.remove("hidden")
                      );
                      moveOverlays.forEach((overlay) =>
                        overlay.classList.remove("hidden")
                      );
                      soundButtons.forEach((btn) => {
                        btn.style.pointerEvents = "none";
                      });
                      setupSortable();
                    }
                  });
                closeSoundEditModal();
              } else {
                alert("Error deleting sound: " + data.error);
              }
            })
            .catch((error) => {
              console.error("Error:", error);
              alert("Error deleting sound");
            });
        }
      }

      function saveSoundChanges() {
        if (!currentEditingSound) return;

        const newName = document.getElementById("edit-sound-name").value.trim();
        const newColor = document.getElementById("edit-button-color").value;

        if (!newName) {
          alert("Please enter a sound name");
          return;
        }

        fetch("/api/update", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            filename: currentEditingSound,
            name: newName,
            color: newColor,
          }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              htmx
                .ajax("GET", "/api/sounds", {
                  target: "#board",
                  swap: "innerHTML",
                })
                .then(() => {
                  updateEditButtonVisibility();
                  if (editMode) {
                    const editSoundButtons =
                      document.querySelectorAll(".edit-sound-btn");
                    const moveOverlays =
                      document.querySelectorAll(".move-overlay");
                    const soundButtons = document.querySelectorAll(".btn");
                    const soundItems = document.querySelectorAll(".sound-item");

                    editSoundButtons.forEach((btn) =>
                      btn.classList.remove("hidden")
                    );
                    moveOverlays.forEach((overlay) =>
                      overlay.classList.remove("hidden")
                    );
                    soundItems.forEach((item) => {
                      item.classList.add("cursor-move");
                    });
                    soundButtons.forEach((btn) => {
                      btn.style.pointerEvents = "none";
                    });
                    setupSortable();
                  }
                });
              closeSoundEditModal();
            } else {
              alert("Error updating sound: " + data.error);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
            alert("Error updating sound");
          });
      }

      // Add press animation for buttons
      document.addEventListener("htmx:afterSettle", function (evt) {
        document.querySelectorAll(".btn").forEach(bindPressAnimation);
        updateEditButtonVisibility();
        if (editMode) {
          setupSortable();
        }
      });

      function bindPressAnimation(btn) {
        const down = (e) => {
          if (e.cancelable) e.preventDefault();
          btn.classList.add("pressed");
        };
        const up = () => btn.classList.remove("pressed");
        btn.addEventListener("pointerdown", down, { passive: false });
        btn.addEventListener("pointerup", up);
        btn.addEventListener("pointerleave", up);
        btn.addEventListener("pointercancel", up);
      }

      // Audio device management
      let settingsPanelOpen = false;
      let masterVolume = 100; // Global master volume (0-100)

      function toggleSettingsPanel() {
        settingsPanelOpen = !settingsPanelOpen;
        const panel = document.getElementById("settings-panel");

        if (settingsPanelOpen) {
          panel.classList.remove("hidden");
          loadAudioDevices();
          // Update volume slider to current value
          document.getElementById("volume-slider").value = masterVolume;
          document.getElementById("volume-display").textContent =
            masterVolume + "%";
        } else {
          panel.classList.add("hidden");
        }
      }

      function updateMasterVolume(value) {
        masterVolume = parseInt(value);
        document.getElementById("volume-display").textContent =
          masterVolume + "%";

        // Send volume update to backend
        fetch("/api/set-volume", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ volume: masterVolume }),
        }).catch((error) => {
          console.error("Error setting volume:", error);
        });
      }

      function loadAudioDevices() {
        fetch("/api/audio-devices")
          .then((response) => response.json())
          .then((data) => {
            const select = document.getElementById("device-select");
            select.innerHTML = "";

            if (data.devices && data.devices.length > 0) {
              data.devices.forEach((device) => {
                const option = document.createElement("option");
                option.value = device.id;
                option.textContent = `${device.name} (${device.channels} ch)`;
                if (device.is_default) {
                  option.textContent += " [Default]";
                }
                if (device.id === data.current_device) {
                  option.selected = true;
                }
                select.appendChild(option);
              });
            } else {
              const option = document.createElement("option");
              option.value = "";
              option.textContent = "No audio devices found";
              select.appendChild(option);
            }

            // Update volume slider with current volume from backend
            if (data.volume !== undefined) {
              masterVolume = data.volume;
              document.getElementById("volume-slider").value = masterVolume;
              document.getElementById("volume-display").textContent =
                masterVolume + "%";
            }
          })
          .catch((error) => {
            console.error("Error loading audio devices:", error);
            const select = document.getElementById("device-select");
            select.innerHTML =
              '<option value="">Error loading devices</option>';
          });
      }

      function selectAudioDevice(deviceId) {
        if (deviceId === "") return;

        fetch("/api/select-device", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ device_id: parseInt(deviceId) }),
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              console.log("Audio device selected:", deviceId);
            } else {
              console.error("Error selecting device:", data.error);
              alert("Error selecting audio device: " + data.error);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
            alert("Error selecting audio device");
          });
      }

      function refreshAudioDevices() {
        loadAudioDevices();
      }

      // Stop all sounds function
      function stopAllSounds() {
        fetch("/api/stop-all", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            if (data.success) {
              console.log(data.message);
            } else {
              console.error("Error stopping sounds:", data.error);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
          });
      }

      // Initialize animations for existing buttons
      document.addEventListener("DOMContentLoaded", function () {
        document.querySelectorAll(".btn").forEach(bindPressAnimation);
        // Force show edit button for testing
        const editBtn = document.getElementById("edit-btn");
        if (editBtn) {
          editBtn.style.display = "flex";
        }
        updateEditButtonVisibility();
      });
    </script>
  </body>
</html>
